# 工厂

## 简单工厂

```javascript
class Popup {
  constructor(opts = {}) {
    this.opts = opts;
  }
  getInstance({ type, ...opts }) {
    switch (type) {
      case 'modal':
        return new Modal(opts);
        break;
      case 'prompt':
        return new Prompt(opts);
        break;
      case 'toast':
        return new Toast(opts);
        break;
      default:
        throw new Error('参数错误');
    }
  }
}
// 使用
const toast = Popup.getInstance({ type: 'toast', id: 'toast' });
```

## 工厂方法

```javascript
class Popup {
  constructor(opts = {}) {
    if (new.target === Popup) {
      throw new Erorr('抽象类不能实例化');
    }
    this.opts = opts;
  }
}

class PopupFactory extends Popup {
  constructor(opts) {
    super(opts);
  }
  create({type, ...opts}) {
    case 'modal':
      return new Modal(opts);
      break;
    case 'prompt':
      return new Prompt(opts);
      break;
    case 'toast':
      return new Toast(opts);
      break;
    default:
      throw new Error('参数错误');
  }
}
// 使用
let popupFactory = new PopupFactory()
const toast = popupFactory.popupFactory({ type: 'toast', id: 'toast' });
```

## 抽象工厂

```javascript
class Popup {
  constructor(opts = {}) {
    if (new.target === Popup) {
      throw new Erorr('抽象类不能实例化');
    }
    this.opts = opts;
  }
}
class Modal extends Popup {
  constructor(opts) {
    super(opts);
    this.type = 'modal';
  }
}
class Toast mextends Popup {
  constructor(opts) {
    super(opts);
    this.type = 'toast';
  }
}
const popupFactory = ({type, ...opts}) => {
  switch (type) {
    case 'modal':
      return Modal;
      break;
    case 'toast':
      return Toast;
      break;
    default:
      throw new Error('参数错误');
  }
};
// 使用
let Modal = popupFactory('modal');
let Toast = popupFactory('toast');

let modal = new Modal({id: 'modal'});
let toast = new Toast({id: 'toast'});
```

# 单例

```javascript
class Singleton {
  constructor(...opts) {
    this.opts = opts;
  }
  static getInstance(...args) {
    if (!this.instance) {
      this.instance = new Singleton(...args);
    }
    return this.instance;
  }
}
```

# 适配器

> 你不应该在软件的初期开发阶段就使用该模式，这是一个亡羊补牢的兼容策略

```javascript
class Adapter {
  constructor(oldApi) {
    this.api = oldApi;
  }
  request(params) {
    console.log('参数适配');
    const { url, ...rest } = params;
    this.adaptee.request(url, ...rest);
  }
}
class OldApi {
  request(paramList) {
    console.log('调用老接口');
  }
}
// new OldApi().request('url', '1', '1002')
new Adapter(new OldApi()).request({
  url: 'url',
  type: '1',
  id: '1002',
});
```

# 装饰器

先来看看 es7 中的语法糖

```javascript
function testable(isTestable) {
  return function(target) {
    target.isTestable = isTestable;
  };
}

@testable(true)
class MyTestableClass {}
MyTestableClass.isTestable; // true
```

AOP 装饰函数

```javascript
Function.prototype.before = function(beforeFn) {
  const fn = this;
  return (...args) => {
    beforeFn.apply(this, args);
    return fn.apply(this, args);
  };
};
Function.prototype.after = function(afterFn) {
  const fn = this;
  return (...args) => {
    const result = fn.apply(this, args);
    afterFn.apply(this, args);
    return result;
  };
};
function func() {
  console.debug('fn apply');
}
const enhancedFunc = func
  .before(() => console.debug('before'))
  .after(() => console.debug('after'));
```

# 代理模式

```javascript
```
